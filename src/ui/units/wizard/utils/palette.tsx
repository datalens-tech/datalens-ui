import React from 'react';

import type {SelectOption, SelectOptionGroup} from '@gravity-ui/uikit';
import AutogeneratedPaletteIcon from 'components/AutogeneratedPaletteIcon/AutogeneratedPaletteIcon';
import {i18n} from 'i18n';
import type {
    ColorPalette,
    Gradient,
    GradientPalettes,
    GradientType,
    InternalPaletteId,
    Palettes,
} from 'shared';
import {getPalettesOrder} from 'shared';
import {selectAvailableClientPalettes} from 'ui';

import {PaletteIcon, PaletteType} from '../components/PaletteIcon/PaletteIcon';

export const getPaletteSelectorItems = ({
    colorPalettes = [],
    order,
}: {
    colorPalettes?: ColorPalette[];
    order?: (keyof Palettes)[];
}): SelectOptionGroup<{icon: JSX.Element}>[] => {
    const availablePalettes = selectAvailableClientPalettes();
    const palettesOrder = order || getPalettesOrder();

    const result: SelectOptionGroup<{icon: JSX.Element}>[] = palettesOrder.map(
        (paletteName: keyof Palettes): SelectOptionGroup<{icon: JSX.Element}> => {
            const palette = availablePalettes[paletteName];
            const options = palette.map(
                (item: string): SelectOption<{icon: JSX.Element}> => ({
                    data: {
                        icon: (
                            <PaletteIcon paletteType={PaletteType.ColorPalette} paletteId={item} />
                        ),
                    },
                    content: i18n('wizard.palette', `label_${item as InternalPaletteId}`),
                    value: item,
                    qa: item,
                }),
            );

            return {
                label: '',
                options,
            };
        },
    );

    if (colorPalettes.length) {
        return result.concat({
            label: '',
            options: colorPalettes.map(
                (colorPalette): SelectOption<{icon: JSX.Element}> => ({
                    data: {
                        icon: (
                            <AutogeneratedPaletteIcon
                                colors={colorPalette.colors}
                                height="16px"
                                width="20px"
                            />
                        ),
                    },
                    content: colorPalette.displayName,
                    value: colorPalette.colorPaletteId,
                }),
            ),
        });
    }

    return result;
};

function mapGradientToSelectOption(gradient: Gradient) {
    return {
        data: {
            icon: (
                <AutogeneratedPaletteIcon
                    colors={gradient.colors}
                    isGradient={true}
                    height="16px"
                    width="20px"
                />
            ),
        },
        content: gradient.title || i18n('wizard', `label_${gradient.id as GradientType}`),
        value: gradient.id,
    };
}

export const getGradientSelectorItems = (
    gradients: GradientPalettes,
): SelectOptionGroup<{icon: JSX.Element}>[] => {
    const basePalettes: Gradient[] = [];
    const namedPalettes: Gradient[] = [];

    Object.values(gradients).forEach((item) => {
        if (item.title) {
            namedPalettes.push(item);
        } else {
            basePalettes.push(item);
        }
    });

    const result: SelectOptionGroup<{icon: JSX.Element}>[] = [];
    if (basePalettes.length) {
        result.push({
            label: '',
            options: basePalettes.map(mapGradientToSelectOption),
        });
    }

    if (namedPalettes.length) {
        result.push({
            label: '',
            options: namedPalettes.map(mapGradientToSelectOption),
        });
    }

    return result;
};
